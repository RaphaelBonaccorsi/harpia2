File: scripts/action_node_example.py
#!/usr/bin/env python3

import os, sys, rclpy
from ament_index_python.packages import get_package_share_directory
package_share_path = get_package_share_directory("route_executor2")
scripts_path = os.path.join(package_share_path, 'scripts')
sys.path.append(scripts_path)

from action_executor_base import ActionExecutorBase
from rclpy.lifecycle import LifecycleNode, TransitionCallbackReturn, LifecycleState

class ActionNodeExample(ActionExecutorBase):

    def __init__(self):
        super().__init__("action_node_example")
        self.get_logger().info("ActionNodeExample initialized")

        self.index = 0

    def on_configure_extension(self):
        self.get_logger().info("Configuring... (example)")
        return TransitionCallbackReturn.SUCCESS
    

    def new_goal(self, goal_request):
        self.get_logger().info("New goal received")
        self.index = 0
        return True

    def execute_goal(self, goal_handle):
        self.get_logger().info("Executing goal")
        self.index += 1

        if self.index >= 60:
            self.get_logger().info("Goal completed")
            return True, 1.0
        
        self.get_logger().info(f"Goal status {self.index}/60")
        return False, self.index/60
            

    def cancel_goal(self, goal_handle):
        self.get_logger().info("Canceling goal")

def main(args=None):
    rclpy.init(args=args)
    node = ActionNodeExample()
    rclpy.spin(node)
    rclpy.shutdown()

if __name__ == '__main__':
    main()
File: scripts/action_executor_base.py
from rclpy.lifecycle import LifecycleNode, TransitionCallbackReturn, LifecycleState
from rclpy.action import ActionServer, CancelResponse, GoalResponse
import rclpy
from rclpy.task import Future
import time

from harpia_msgs.action import ActionCaller

class ActionExecutorBase(LifecycleNode):

    def __init__(self, node_name):
        super().__init__(node_name)
        self._node_name = node_name
        self.get_logger().info("ActionExecutorBase initialized")

    def on_configure(self, previous_state: LifecycleState) -> TransitionCallbackReturn:
        self.get_logger().info('Configuring... (base class)')
        return self.on_configure_extension()
    def on_configure_extension(self):
        """For child classes to override. Return SUCCESS by default."""
        return TransitionCallbackReturn.SUCCESS

    def on_activate(self, previous_state: LifecycleState) -> TransitionCallbackReturn:
        self.get_logger().info('Activating... (base class)')

        self._action_server = ActionServer(
            self,
            ActionCaller,
            '/action/'+self._node_name,
            execute_callback   = self.execute_cb,
            goal_callback      = self.goal_cb,
            cancel_callback    = self.cancel_cb
        )

        return self.on_activate_extension()
    def on_activate_extension(self):
        """For child classes to override. Return SUCCESS by default."""
        return TransitionCallbackReturn.SUCCESS

    def on_deactivate(self, previous_state: LifecycleState) -> TransitionCallbackReturn:
        self.get_logger().info('Deactivating... (base class)')
        return self.on_deactivate_extension()
    def on_deactivate_extension(self):
        """For child classes to override. Return SUCCESS by default."""
        return TransitionCallbackReturn.SUCCESS

    def on_cleanup(self, previous_state: LifecycleState) -> TransitionCallbackReturn:
        self.get_logger().info('Cleaning up... (base class)')
        return self.on_cleanup_extension()
    def on_cleanup_extension(self):
        """For child classes to override. Return SUCCESS by default."""
        return TransitionCallbackReturn.SUCCESS

    def on_shutdown(self, previous_state: LifecycleState) -> TransitionCallbackReturn:
        self.get_logger().info('Shutting down... (base class)')
        return self.on_shutdown_extension()
    def on_shutdown_extension(self):
        """For child classes to override. Return SUCCESS by default."""
        return TransitionCallbackReturn.SUCCESS
    


    # ---- callbacks -------------------------------------------------
    def goal_cb(self, goal_request):
        self.get_logger().info(f'Received goal: {str(goal_request)}')

        if self.new_goal(goal_request):
            return GoalResponse.ACCEPT 
        else:
            return GoalResponse.REJECT

    def cancel_cb(self, goal_handle):
        self.get_logger().info('Received cancel request')
        return CancelResponse.ACCEPT

    def execute_cb(self, goal_handle):
        self.get_logger().info(
            f"Executing action: {goal_handle.request.action_name} "
            f"params: {goal_handle.request.parameters}")
        
        

        while True:
            if goal_handle.is_cancel_requested:
                self.get_logger().info('Goal canceled')
                self.cancel_goal(goal_handle)
                goal_handle.canceled()
                return ActionCaller.Result()

            self.get_logger().info(f"Executing step")
            finish, status = self.execute_goal(goal_handle)
            feedback = ActionCaller.Feedback()
            feedback.status = status
            goal_handle.publish_feedback(feedback)

            if finish:
                break
            time.sleep(1.0)

        self.get_logger().info('Goal succeeded')
        result = ActionCaller.Result()
        result.success = True
        goal_handle.succeed()
        return result

    # -------------------------------------------------------------------

    
    def new_goal(self, goal_request):
        raise NotImplementedError("Subclasses should implement this method.")
    
    def execute_goal(self, goal_handle):
        raise NotImplementedError("Subclasses should implement this method.")
    
    def cancel_goal(self, goal_handle):
        raise NotImplementedError("Subclasses should implement this method.")
